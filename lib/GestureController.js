// Generated by CoffeeScript 1.10.0
(function() {
  var GestureController,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  GestureController = (function() {
    function GestureController(config, feedback, actionController) {
      this.parseGestures = bind(this.parseGestures, this);
      this.getActiveSigns = bind(this.getActiveSigns, this);
      this.assertSign = bind(this.assertSign, this);
      this.assertGesture = bind(this.assertGesture, this);
      this.assertHand = bind(this.assertHand, this);
      this.updateRecipeRecord = bind(this.updateRecipeRecord, this);
      this.updateSignRecord = bind(this.updateSignRecord, this);
      this.wipeRecord = bind(this.wipeRecord, this);
      this.resetSignRecord = bind(this.resetSignRecord, this);
      var recipe, recipeName, ref, ref1, sign, signName, state;
      this.config = config;
      this.feedback = feedback;
      this.actionHero = actionController;
      this.startTime = null;
      state = {};
      state.lastTimestamp = 0;
      state.currentTimestamp = 0;
      state.signRecord = {};
      state.recipeRecord = {};
      state.activeSigns = [];
      state.lastActiveSigns = [];
      state.timeout = this.config.timeout;
      ref = this.config.signs;
      for (signName in ref) {
        sign = ref[signName];
        sign.name = signName;
        sign.timeVisible = 0;
        sign.status = 'inactive';
        state.signRecord[signName] = sign;
      }
      ref1 = this.config.recipes;
      for (recipeName in ref1) {
        recipe = ref1[recipeName];
        recipe.name = recipeName;
        recipe.timeVisible = 0;
        recipe.signIndex = 0;
        state.recipeRecord[recipeName] = recipe;
      }
      this.state = state;
      this.currentFrame = {};
    }

    GestureController.prototype.resetSignRecord = function(sign) {
      var data;
      data = this.state.signRecord[sign];
      data.status = 'inactive';
      return data.timeVisible = 0;
    };

    GestureController.prototype.wipeRecord = function() {
      var manager, recipe, results, sign;
      manager = this.actionHero;
      for (sign in this.state.signRecord) {
        this.resetSignRecord(sign);
      }
      results = [];
      for (recipe in this.state.recipeRecord) {
        this.state.recipeRecord[recipe].signIndex = 0;
        results.push(manager.tearDownRecipe(recipe));
      }
      return results;
    };

    GestureController.prototype.updateSignRecord = function(sign) {
      var data, oldStatus;
      data = this.state.signRecord[sign];
      oldStatus = data.status;
      if (this.assertSign(data, this.state.currentFrame)) {
        if (oldStatus !== 'inactive') {
          data.timeVisible += this.state.currentTimestamp - this.state.lastTimestamp;
        }
        if (!data.minTime || data.minTime < data.timeVisible) {
          return data.status = 'active';
        } else {
          return data.status = 'pending';
        }
      } else {
        return this.resetSignRecord(sign);
      }
    };

    GestureController.prototype.updateRecipeRecord = function(recipe) {
      var data, manager, oldIndex, secondaryIndex, secondarySign, sign;
      data = this.state.recipeRecord[recipe];
      oldIndex = data.signIndex;
      sign = data.signs[oldIndex];
      if (indexOf.call(this.state.activeSigns, sign) >= 0) {
        data.signIndex += 1;
      } else if (oldIndex > 0) {
        secondaryIndex = oldIndex - 1;
        secondarySign = data.signs[secondaryIndex];
        if (indexOf.call(this.state.activeSigns, secondarySign) >= 0) {
          data.signIndex = oldIndex;
        } else {
          data.signIndex = 0;
        }
      } else {
        data.signIndex = 0;
      }
      manager = this.actionHero;
      if (data.signIndex === data.signs.length) {
        return manager.activateRecipe(data.name);
      } else {
        manager.tearDownRecipe(data.name);
        return manager.tearDownRecipe(data.name);
      }
    };

    GestureController.prototype.assertHand = function(sign, handModel) {
      var extendedFingers, grabStrength, pinchStrength, pincher, sign_ok;
      sign_ok = true;
      if (sign.grab) {
        grabStrength = handModel.grabStrength;
        if (sign.grab.min) {
          if (grabStrength < sign.grab.min) {
            sign_ok = false;
          }
        }
        if (sign.grab.max) {
          if (grabStrength > sign.grab.max) {
            sign_ok = false;
          }
        }
      }
      if (sign.pinch) {
        pinchStrength = handModel.pinchStrength;
        pincher = handModel.pinchingFinger;
        if (sign.pinch.pincher) {
          if (sign.pinch.pincher !== pincher) {
            sign_ok = false;
          }
        }
        if (sign.pinch.min) {
          if (pinchStrength < sign.pinch.min) {
            sign_ok = false;
          }
        }
        if (sign.pinch.max) {
          if (pinchStrength > sign.pinch.max) {
            sign_ok = false;
          }
        }
      }
      if (sign.extendedFingers) {
        extendedFingers = sign.extendedFingers;
        if ((extendedFingers.indexFinger != null)) {
          if (extendedFingers.indexFinger !== handModel.extendedFingers.indexFinger) {
            sign_ok = false;
          }
        }
        if ((extendedFingers.middleFinger != null)) {
          if (extendedFingers.middleFinger !== handModel.extendedFingers.middleFinger) {
            sign_ok = false;
          }
        }
        if ((extendedFingers.ringFinger != null)) {
          if (extendedFingers.ringFinger !== handModel.extendedFingers.ringFinger) {
            sign_ok = false;
          }
        }
        if ((extendedFingers.pinky != null)) {
          if (extendedFingers.pinky !== handModel.extendedFingers.pinky) {
            sign_ok = false;
          }
        }
        if ((extendedFingers.thumb != null)) {
          if (extendedFingers.thumb !== handModel.extendedFingers.thumb) {
            sign_ok = false;
          }
        }
      }
      if (sign.hover) {
        if (sign.hover.left != null) {
          if (hand.type === !'left' && sign.hover.left === true) {
            sign_ok = false;
          }
        }
        if (sign.hover.minTime != null) {
          if (sign.hover.minTime > hand.timeVisible) {
            sign_ok = false;
          }
        }
      }
      if (sign.direction) {
        if (sign.direction !== handModel.direction) {
          sign_ok = false;
        }
      }
      return sign_ok;
    };

    GestureController.prototype.assertGesture = function(sign, gestureData) {
      var ref, ref1, ref2, ref3;
      if (sign.circle) {
        if (gestureData.type !== 'circle') {
          return false;
        }
        if (sign.circle.direction != null) {
          if (gestureData.direction !== sign.circle.direction) {
            return false;
          }
        }
        if (((ref = sign.circle.progress) != null ? ref.min : void 0) != null) {
          if (sign.circle.progress.min > gestureData.progress) {
            return false;
          }
        }
        if (((ref1 = sign.circle.progress) != null ? ref1.max : void 0) != null) {
          if (sign.circle.progress.max < gestureData.progress) {
            return false;
          }
        }
        if (((ref2 = sign.circle.duration) != null ? ref2.min : void 0) != null) {
          if (sign.circle.duration.min > gestureData.duration) {
            return false;
          }
        }
        if (((ref3 = sign.circle.duration) != null ? ref3.max : void 0) != null) {
          if (sign.circle.duration.max < gestureData.duration) {
            return false;
          }
        }
      }
      return true;
    };

    GestureController.prototype.assertSign = function(sign, frameData) {
      var gestureModel, gesture_ok, gesture_spotted, handModel, hand_ok, hand_spotted, i, j, len, len1, ref, ref1, sign_ok;
      sign_ok = true;
      hand_spotted = false;
      ref = frameData.hands;
      for (i = 0, len = ref.length; i < len; i++) {
        handModel = ref[i];
        hand_ok = this.assertHand(sign, handModel);
        if (hand_ok) {
          hand_spotted = true;
        }
      }
      if (!hand_spotted) {
        sign_ok = false;
      }
      if (sign.circle || sign.swipe) {
        if (frameData.gestures.length === 0) {
          sign_ok = false;
        }
        gesture_spotted = false;
        ref1 = frameData.gestures;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          gestureModel = ref1[j];
          gesture_ok = this.assertGesture(sign, gestureModel);
          if (gesture_ok) {
            gesture_spotted = true;
          }
        }
        if (!gesture_spotted) {
          sign_ok = false;
        }
      }
      return sign_ok;
    };

    GestureController.prototype.getActiveSigns = function() {
      var activeSigns, data, options, ref, ref1, ref2, sign;
      activeSigns = [];
      ref = this.state.signRecord;
      for (sign in ref) {
        data = ref[sign];
        if (data.status === 'active') {
          activeSigns.push(sign);
          if (((ref1 = data.feedback) != null ? ref1.audio : void 0)) {
            if ((indexOf.call(this.state.lastActiveSigns, sign) < 0)) {
              this.feedback.audioNotification(data.feedback.audio);
            }
          }
          if ((((ref2 = data.feedback) != null ? ref2.visual : void 0) != null)) {
            options = data.feedback.visual;
            this.feedback.visualNotification(options.id, options.msg);
          }
        }
      }
      return activeSigns;
    };

    GestureController.prototype.parseGestures = function(model) {
      var callback, confidence, delay, elapsedMS, elapsedSeconds, manager, recipe, sign, visible;
      clearTimeout(this.timerID);
      this.state.lastActiveSigns = this.state.activeSigns;
      manager = this.actionHero;
      manager.position = model.hands[0].position;
      this.state.lastTimestamp = this.state.currentTimestamp;
      this.state.currentTimestamp = model.timestamp;
      this.state.currentFrame = model;
      if (!this.startTime) {
        this.startTime = model.timestamp;
      } else {
        this.currentTotalTime = model.timestamp;
      }
      elapsedMS = this.currentTotalTime - this.startTime;
      elapsedSeconds = elapsedMS / 1000000;
      this.feedback.time(elapsedSeconds);
      visible = model.hands[0].visible;
      this.feedback.handVisible(visible);
      confidence = model.hands[0].confidence;
      this.feedback.confidenceMeter(confidence);
      for (sign in this.state.signRecord) {
        this.updateSignRecord(sign);
      }
      this.state.activeSigns = this.getActiveSigns();
      for (recipe in this.state.recipeRecord) {
        this.updateRecipeRecord(recipe);
      }
      callback = (function(_this) {
        return function() {
          return _this.wipeRecord();
        };
      })(this);
      delay = this.config.timeout;
      return this.timerID = setTimeout(callback, delay);
    };

    return GestureController;

  })();

  module.exports = GestureController;

}).call(this);
